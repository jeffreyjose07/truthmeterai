import * as vscode from 'vscode';
import { LocalStorage } from '../storage/LocalStorage';
import { AIEvent } from '../types/events';

export class AIEventCollector {
    private events: AIEvent[] = [];
    private currentSession: string;
    private lastSuggestion: any = null;
    private modificationTracker: Map<string, any> = new Map();

    constructor(private storage: LocalStorage) {
        this.currentSession = this.generateSessionId();
    }

    startTracking() {
        this.trackCascadeEvents();
        this.trackDocumentChanges();
        this.trackInlineSuggestions();
    }

    private trackCascadeEvents() {
        vscode.window.onDidChangeActiveTextEditor((editor) => {
            if (!editor) {return;}

            const aiMarkers = this.detectAIMarkers(editor.document);
            if (aiMarkers.length > 0) {
                this.recordAIUsage(aiMarkers);
            }
        });
    }

    private trackDocumentChanges() {
        vscode.workspace.onDidChangeTextDocument((event) => {
            if (this.isAIGenerated(event)) {
                const aiEvent: AIEvent = {
                    timestamp: Date.now(),
                    type: 'suggestion',
                    sessionId: this.currentSession,
                    fileType: event.document.languageId,
                    suggestionLength: this.calculateChangeSize(event),
                    acceptedLength: 0,
                    modificationTime: 0,
                    contextSize: event.document.lineCount
                };

                this.events.push(aiEvent);
                this.lastSuggestion = aiEvent;

                this.trackModifications(event.document.uri.toString(), aiEvent);
            }
        });
    }

    private trackInlineSuggestions() {
        const disposable = vscode.languages.registerInlineCompletionItemProvider(
            { pattern: '**/*' },
            {
                provideInlineCompletionItems: async (document, position, context, token) => {
                    this.recordSuggestionShown(document, position);
                    return undefined;
                }
            }
        );
    }

    private isAIGenerated(event: vscode.TextDocumentChangeEvent): boolean {
        const changeText = event.contentChanges[0]?.text || '';

        const hasAIMarkers =
            changeText.length > 100 ||
            this.detectAIPatterns(changeText) ||
            this.checkRecentAIActivity();

        return hasAIMarkers;
    }

    private detectAIPatterns(text: string): boolean {
        const patterns = [
            /\/\/ TODO: Implement/gi,
            /function\s+\w+\([^)]*\)\s*{\s*\/\/ Implementation/gi,
            /catch\s*\([^)]+\)\s*{\s*console\.error/gi,
            /^\s*(import|const|let|var)\s+/gm
        ];

        return patterns.some(pattern => pattern.test(text));
    }

    private detectAIMarkers(document: vscode.TextDocument): any[] {
        const markers = [];
        const text = document.getText();

        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
            if (this.isLikelyAIGenerated(lines[i])) {
                markers.push({ line: i, content: lines[i] });
            }
        }

        return markers;
    }

    private isLikelyAIGenerated(line: string): boolean {
        return line.includes('// Generated by') ||
               line.includes('// AI:') ||
               line.includes('TODO: Implement') ||
               (line.match(/^\s*\/\//g) !== null && line.length > 80);
    }

    private trackModifications(uri: string, event: AIEvent) {
        setTimeout(() => {
            vscode.workspace.openTextDocument(vscode.Uri.parse(uri)).then(doc => {
                const currentText = doc.getText();
                const modifications = this.detectModifications(currentText, event);

                if (modifications > 0) {
                    event.modificationTime = Date.now() - event.timestamp;
                    event.acceptedLength = event.suggestionLength - modifications;

                    const churnRate = modifications / event.suggestionLength;
                    this.recordChurn(churnRate);
                }
            });
        }, 5000);
    }

    private detectModifications(currentText: string, originalEvent: AIEvent): number {
        return Math.abs(currentText.length - originalEvent.suggestionLength);
    }

    private recordChurn(rate: number) {
        const churnEvent = {
            timestamp: Date.now(),
            type: 'churn' as const,
            rate: rate
        };

        this.storage.store('churn_events', churnEvent);
    }

    private calculateChangeSize(event: vscode.TextDocumentChangeEvent): number {
        return event.contentChanges.reduce((sum, change) => {
            return sum + change.text.length;
        }, 0);
    }

    private checkRecentAIActivity(): boolean {
        const recentThreshold = Date.now() - 10000;
        return this.events.some(e => e.timestamp > recentThreshold);
    }

    private recordAIUsage(markers: any[]) {
        this.storage.store('ai_usage', {
            timestamp: Date.now(),
            markers: markers.length,
            session: this.currentSession
        });
    }

    private recordSuggestionShown(document: vscode.TextDocument, position: vscode.Position) {
        this.storage.store('suggestion_shown', {
            timestamp: Date.now(),
            file: document.fileName,
            line: position.line,
            character: position.character
        });
    }

    private generateSessionId(): string {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    async getMetrics() {
        const events = this.events;
        const totalSuggestions = events.filter(e => e.type === 'suggestion').length;
        const acceptedSuggestions = events.filter(e => e.acceptedLength > 0).length;

        return {
            totalSuggestions,
            acceptanceRate: totalSuggestions > 0 ? acceptedSuggestions / totalSuggestions : 0,
            averageModificationTime: this.calculateAverageModificationTime(),
            churnRate: await this.calculateChurnRate(),
            sessionCount: this.getUniqueSessionCount()
        };
    }

    private calculateAverageModificationTime(): number {
        const modifications = this.events.filter(e => e.modificationTime > 0);
        if (modifications.length === 0) {return 0;}

        const total = modifications.reduce((sum, e) => sum + e.modificationTime, 0);
        return total / modifications.length;
    }

    private async calculateChurnRate(): Promise<number> {
        const churnEvents = await this.storage.get('churn_events') || [];
        if (churnEvents.length === 0) {return 0;}

        const totalRate = churnEvents.reduce((sum: number, e: any) => sum + e.rate, 0);
        return totalRate / churnEvents.length;
    }

    private getUniqueSessionCount(): number {
        const sessions = new Set(this.events.map(e => e.sessionId));
        return sessions.size;
    }

    getQuickStats() {
        const last5Minutes = Date.now() - 300000;
        const recentEvents = this.events.filter(e => e.timestamp > last5Minutes);

        return {
            recentSuggestions: recentEvents.filter(e => e.type === 'suggestion').length,
            recentAcceptance: recentEvents.filter(e => e.acceptedLength > 0).length,
            activeSession: this.currentSession
        };
    }
}
